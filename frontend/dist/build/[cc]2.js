
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a as append_styles, m as create_slot, b as validate_slots, _ as createEventDispatcher, $ as setContext, ab as onDestroy, a0 as writable, e as element, g as attr_dev, h as add_location, j as insert_dev, q as update_slot_base, r as get_all_dirty_from_scope, w as get_slot_changes, y as transition_in, z as transition_out, l as detach_dev, P as binding_callbacks, ai as bind, ao as afterUpdate, A as create_component, B as mount_component, aj as add_flush_callback, C as destroy_component, O as bubble, o as toggle_class, L as listen_dev, n as noop, f as space, ad as empty, D as set_style, X as add_render_callback, k as append_dev, a8 as add_resize_listener, Q as group_outros, R as check_outros, N as run_all, a5 as onMount, a1 as getContext, p as action_destroyer, x as is_function, v as validate_store, c as component_subscribe, U as goto, am as params, u as url, T as currentCountry, ak as handle_promise, al as update_await_block_branch, W as validate_each_argument, E as src_url_equal, t as text, Z as destroy_each } from './main.js';
import { I as Icon, C as Class, R as Ripple, M as MaterialApp, m as mdiRefresh, H as Header } from './Header.js';
import { C as Card } from './Card.js';
import { C as CardText, a as CardTitle, b as Carousel_1 } from './Carousel.js';

/* node_modules/svelte-materialify/dist/components/ItemGroup/ItemGroup.svelte generated by Svelte v3.42.1 */
const file$7 = "node_modules/svelte-materialify/dist/components/ItemGroup/ItemGroup.svelte";

function add_css$6(target) {
	append_styles(target, "svelte-z4hdem", ".s-item-group{flex:0 1 auto;position:relative;max-width:100%;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSXRlbUdyb3VwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtRGdELGFBQUEsQUFBQSxDQUFBLCtGQUFnSCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJJdGVtR3JvdXAuc3ZlbHRlIl19 */");
}

function create_fragment$7(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "s-item-group " + /*klass*/ ctx[0]);
			attr_dev(div, "role", /*role*/ ctx[1]);
			attr_dev(div, "style", /*style*/ ctx[2]);
			add_location(div, file$7, 57, 0, 1536);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-item-group " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*role*/ 2) {
				attr_dev(div, "role", /*role*/ ctx[1]);
			}

			if (!current || dirty & /*style*/ 4) {
				attr_dev(div, "style", /*style*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const ITEM_GROUP = {};

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ItemGroup', slots, ['default']);
	let { class: klass = '' } = $$props;
	let { activeClass = '' } = $$props;
	let { value = [] } = $$props;
	let { multiple = false } = $$props;
	let { mandatory = false } = $$props;
	let { max = Infinity } = $$props;
	let { role = null } = $$props;
	let { style = null } = $$props;
	const dispatch = createEventDispatcher();
	const valueStore = writable(value);
	let startIndex = -1;

	setContext(ITEM_GROUP, {
		select: val => {
			if (multiple) {
				if (value.includes(val)) {
					if (!mandatory || value.length > 1) {
						value.splice(value.indexOf(val), 1);
						$$invalidate(3, value);
					}
				} else if (value.length < max) $$invalidate(3, value = [...value, val]);
			} else if (value === val) {
				if (!mandatory) $$invalidate(3, value = null);
			} else $$invalidate(3, value = val);
		},
		register: setValue => {
			const u = valueStore.subscribe(val => {
				setValue(multiple ? val : [val]);
			});

			onDestroy(u);
		},
		index: () => {
			startIndex += 1;
			return startIndex;
		},
		activeClass
	});

	const writable_props = [
		'class',
		'activeClass',
		'value',
		'multiple',
		'mandatory',
		'max',
		'role',
		'style'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ItemGroup> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('activeClass' in $$props) $$invalidate(4, activeClass = $$props.activeClass);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('multiple' in $$props) $$invalidate(5, multiple = $$props.multiple);
		if ('mandatory' in $$props) $$invalidate(6, mandatory = $$props.mandatory);
		if ('max' in $$props) $$invalidate(7, max = $$props.max);
		if ('role' in $$props) $$invalidate(1, role = $$props.role);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		ITEM_GROUP,
		setContext,
		createEventDispatcher,
		onDestroy,
		writable,
		klass,
		activeClass,
		value,
		multiple,
		mandatory,
		max,
		role,
		style,
		dispatch,
		valueStore,
		startIndex
	});

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('activeClass' in $$props) $$invalidate(4, activeClass = $$props.activeClass);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('multiple' in $$props) $$invalidate(5, multiple = $$props.multiple);
		if ('mandatory' in $$props) $$invalidate(6, mandatory = $$props.mandatory);
		if ('max' in $$props) $$invalidate(7, max = $$props.max);
		if ('role' in $$props) $$invalidate(1, role = $$props.role);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('startIndex' in $$props) startIndex = $$props.startIndex;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 8) {
			valueStore.set(value);
		}

		if ($$self.$$.dirty & /*value*/ 8) {
			dispatch('change', value);
		}
	};

	return [
		klass,
		role,
		style,
		value,
		activeClass,
		multiple,
		mandatory,
		max,
		$$scope,
		slots
	];
}

class ItemGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				class: 0,
				activeClass: 4,
				value: 3,
				multiple: 5,
				mandatory: 6,
				max: 7,
				role: 1,
				style: 2
			},
			add_css$6
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ItemGroup",
			options,
			id: create_fragment$7.name
		});
	}

	get class() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeClass() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeClass(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mandatory() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mandatory(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get role() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set role(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<ItemGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<ItemGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var prevIcon = 'M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z';

var nextIcon = 'M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z';

/* node_modules/svelte-materialify/dist/components/SlideGroup/SlideGroup.svelte generated by Svelte v3.42.1 */
const file$6 = "node_modules/svelte-materialify/dist/components/SlideGroup/SlideGroup.svelte";

function add_css$5(target) {
	append_styles(target, "svelte-1einl4o", ".s-slide-group{display:flex}.s-slide-group__content{display:flex;flex:1 0 auto;position:relative;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1);white-space:nowrap}.s-slide-group__wrapper{contain:content;display:flex;flex:1 1 auto;overflow:hidden;touch-action:none}.s-slide-group__next,.s-slide-group__prev{align-items:center;display:flex;flex:0 1 52px;justify-content:center;min-width:52px;cursor:pointer}.s-slide-group__next.disabled,.s-slide-group__prev.disabled{pointer-events:none;opacity:.5}.s-slide-group__next.disabled.hide-disabled-arrows,.s-slide-group__prev.disabled.hide-disabled-arrows{visibility:hidden;opacity:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVHcm91cC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK0RpRCxjQUFBLEFBQUEsQ0FBQSxvbUJBQThyQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTbGlkZUdyb3VwLnN2ZWx0ZSJdfQ== */");
}

const get_next_slot_changes = dirty => ({});
const get_next_slot_context = ctx => ({});
const get_previous_slot_changes = dirty => ({});
const get_previous_slot_context = ctx => ({});

// (105:2) {#if arrowsVisible}
function create_if_block_1(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const previous_slot_template = /*#slots*/ ctx[17].previous;
	const previous_slot = create_slot(previous_slot_template, ctx, /*$$scope*/ ctx[22], get_previous_slot_context);
	const previous_slot_or_fallback = previous_slot || fallback_block_1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (previous_slot_or_fallback) previous_slot_or_fallback.c();
			attr_dev(div, "class", "s-slide-group__prev");
			toggle_class(div, "disabled", /*x*/ ctx[9] === 0);
			toggle_class(div, "hide-disabled-arrows", /*hideDisabledArrows*/ ctx[2]);
			add_location(div, file$6, 105, 4, 2531);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (previous_slot_or_fallback) {
				previous_slot_or_fallback.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*prev*/ ctx[12], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (previous_slot) {
				if (previous_slot.p && (!current || dirty & /*$$scope*/ 4194304)) {
					update_slot_base(
						previous_slot,
						previous_slot_template,
						ctx,
						/*$$scope*/ ctx[22],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[22])
						: get_slot_changes(previous_slot_template, /*$$scope*/ ctx[22], dirty, get_previous_slot_changes),
						get_previous_slot_context
					);
				}
			}

			if (dirty & /*x*/ 512) {
				toggle_class(div, "disabled", /*x*/ ctx[9] === 0);
			}

			if (dirty & /*hideDisabledArrows*/ 4) {
				toggle_class(div, "hide-disabled-arrows", /*hideDisabledArrows*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previous_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previous_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (previous_slot_or_fallback) previous_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(105:2) {#if arrowsVisible}",
		ctx
	});

	return block;
}

// (111:28)          
function fallback_block_1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { path: prevIcon },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block_1.name,
		type: "fallback",
		source: "(111:28)          ",
		ctx
	});

	return block;
}

// (128:2) {#if arrowsVisible}
function create_if_block$1(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const next_slot_template = /*#slots*/ ctx[17].next;
	const next_slot = create_slot(next_slot_template, ctx, /*$$scope*/ ctx[22], get_next_slot_context);
	const next_slot_or_fallback = next_slot || fallback_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (next_slot_or_fallback) next_slot_or_fallback.c();
			attr_dev(div, "class", "s-slide-group__next");
			toggle_class(div, "disabled", /*x*/ ctx[9] === /*contentWidth*/ ctx[7] - /*wrapperWidth*/ ctx[8]);
			toggle_class(div, "show-arrows", /*hideDisabledArrows*/ ctx[2]);
			add_location(div, file$6, 128, 4, 3116);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (next_slot_or_fallback) {
				next_slot_or_fallback.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*next*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (next_slot) {
				if (next_slot.p && (!current || dirty & /*$$scope*/ 4194304)) {
					update_slot_base(
						next_slot,
						next_slot_template,
						ctx,
						/*$$scope*/ ctx[22],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[22])
						: get_slot_changes(next_slot_template, /*$$scope*/ ctx[22], dirty, get_next_slot_changes),
						get_next_slot_context
					);
				}
			}

			if (dirty & /*x, contentWidth, wrapperWidth*/ 896) {
				toggle_class(div, "disabled", /*x*/ ctx[9] === /*contentWidth*/ ctx[7] - /*wrapperWidth*/ ctx[8]);
			}

			if (dirty & /*hideDisabledArrows*/ 4) {
				toggle_class(div, "show-arrows", /*hideDisabledArrows*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(next_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(next_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (next_slot_or_fallback) next_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(128:2) {#if arrowsVisible}",
		ctx
	});

	return block;
}

// (134:24)          
function fallback_block(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { path: nextIcon },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(134:24)          ",
		ctx
	});

	return block;
}

// (97:0) <ItemGroup   class="s-slide-group {klass}"   on:change   bind:value   {activeClass}   {multiple}   {mandatory}   {max}>
function create_default_slot$3(ctx) {
	let t0;
	let div1;
	let div0;
	let div0_resize_listener;
	let div1_resize_listener;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*arrowsVisible*/ ctx[10] && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);
	let if_block1 = /*arrowsVisible*/ ctx[10] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr_dev(div0, "class", "s-slide-group__content");
			set_style(div0, "transform", "translate(-" + /*x*/ ctx[9] + "px)");
			add_render_callback(() => /*div0_elementresize_handler*/ ctx[18].call(div0));
			add_location(div0, file$6, 120, 4, 2932);
			attr_dev(div1, "class", "s-slide-group__wrapper");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[19].call(div1));
			add_location(div1, file$6, 115, 2, 2775);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			div0_resize_listener = add_resize_listener(div0, /*div0_elementresize_handler*/ ctx[18].bind(div0));
			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[19].bind(div1));
			insert_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div1, "touchstart", /*touchstart*/ ctx[13], { passive: true }, false, false),
					listen_dev(div1, "touchmove", /*touchmove*/ ctx[14], { passive: true }, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*arrowsVisible*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*arrowsVisible*/ 1024) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4194304)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[22],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[22])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[22], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*x*/ 512) {
				set_style(div0, "transform", "translate(-" + /*x*/ ctx[9] + "px)");
			}

			if (/*arrowsVisible*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*arrowsVisible*/ 1024) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			div0_resize_listener();
			div1_resize_listener();
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(97:0) <ItemGroup   class=\\\"s-slide-group {klass}\\\"   on:change   bind:value   {activeClass}   {multiple}   {mandatory}   {max}>",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let itemgroup;
	let updating_value;
	let current;

	function itemgroup_value_binding(value) {
		/*itemgroup_value_binding*/ ctx[20](value);
	}

	let itemgroup_props = {
		class: "s-slide-group " + /*klass*/ ctx[1],
		activeClass: /*activeClass*/ ctx[3],
		multiple: /*multiple*/ ctx[4],
		mandatory: /*mandatory*/ ctx[5],
		max: /*max*/ ctx[6],
		$$slots: { default: [create_default_slot$3] },
		$$scope: { ctx }
	};

	if (/*value*/ ctx[0] !== void 0) {
		itemgroup_props.value = /*value*/ ctx[0];
	}

	itemgroup = new ItemGroup({ props: itemgroup_props, $$inline: true });
	binding_callbacks.push(() => bind(itemgroup, 'value', itemgroup_value_binding));
	itemgroup.$on("change", /*change_handler*/ ctx[21]);

	const block = {
		c: function create() {
			create_component(itemgroup.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(itemgroup, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const itemgroup_changes = {};
			if (dirty & /*klass*/ 2) itemgroup_changes.class = "s-slide-group " + /*klass*/ ctx[1];
			if (dirty & /*activeClass*/ 8) itemgroup_changes.activeClass = /*activeClass*/ ctx[3];
			if (dirty & /*multiple*/ 16) itemgroup_changes.multiple = /*multiple*/ ctx[4];
			if (dirty & /*mandatory*/ 32) itemgroup_changes.mandatory = /*mandatory*/ ctx[5];
			if (dirty & /*max*/ 64) itemgroup_changes.max = /*max*/ ctx[6];

			if (dirty & /*$$scope, x, contentWidth, wrapperWidth, hideDisabledArrows, arrowsVisible*/ 4196228) {
				itemgroup_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty & /*value*/ 1) {
				updating_value = true;
				itemgroup_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			itemgroup.$set(itemgroup_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(itemgroup.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(itemgroup.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(itemgroup, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const SLIDE_GROUP = {};

function instance$6($$self, $$props, $$invalidate) {
	let arrowsVisible;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SlideGroup', slots, ['previous','default','next']);
	let contentWidth;
	let wrapperWidth;
	let { class: klass = '' } = $$props;
	let { showArrows = true } = $$props;
	let { hideDisabledArrows = false } = $$props;
	let { centerActive = false } = $$props;
	let { activeClass = '' } = $$props;
	let { value = [] } = $$props;
	let { multiple = false } = $$props;
	let { mandatory = false } = $$props;
	let { max = Infinity } = $$props;
	let x = 0;

	setContext(SLIDE_GROUP, item => {
		const left = item.offsetLeft;
		const width = item.offsetWidth;

		if (centerActive) $$invalidate(9, x = left + (width - wrapperWidth) / 2); else if (left + 1.25 * width > wrapperWidth + x) {
			$$invalidate(9, x = left + 1.25 * width - wrapperWidth);
		} else if (left < x + width / 4) {
			$$invalidate(9, x = left - width / 4);
		}
	});

	afterUpdate(() => {
		if (x + wrapperWidth > contentWidth) $$invalidate(9, x = contentWidth - wrapperWidth); else if (x < 0) $$invalidate(9, x = 0);
	});

	function next() {
		$$invalidate(9, x += wrapperWidth);
	}

	function prev() {
		$$invalidate(9, x -= wrapperWidth);
	}

	let touchStartX;

	function touchstart({ touches }) {
		touchStartX = x + touches[0].clientX;
	}

	function touchmove({ touches }) {
		$$invalidate(9, x = touchStartX - touches[0].clientX);
	}

	const writable_props = [
		'class',
		'showArrows',
		'hideDisabledArrows',
		'centerActive',
		'activeClass',
		'value',
		'multiple',
		'mandatory',
		'max'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SlideGroup> was created with unknown prop '${key}'`);
	});

	function div0_elementresize_handler() {
		contentWidth = this.clientWidth;
		$$invalidate(7, contentWidth);
	}

	function div1_elementresize_handler() {
		wrapperWidth = this.clientWidth;
		$$invalidate(8, wrapperWidth);
	}

	function itemgroup_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(1, klass = $$props.class);
		if ('showArrows' in $$props) $$invalidate(15, showArrows = $$props.showArrows);
		if ('hideDisabledArrows' in $$props) $$invalidate(2, hideDisabledArrows = $$props.hideDisabledArrows);
		if ('centerActive' in $$props) $$invalidate(16, centerActive = $$props.centerActive);
		if ('activeClass' in $$props) $$invalidate(3, activeClass = $$props.activeClass);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('multiple' in $$props) $$invalidate(4, multiple = $$props.multiple);
		if ('mandatory' in $$props) $$invalidate(5, mandatory = $$props.mandatory);
		if ('max' in $$props) $$invalidate(6, max = $$props.max);
		if ('$$scope' in $$props) $$invalidate(22, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		SLIDE_GROUP,
		setContext,
		afterUpdate,
		ItemGroup,
		prevIcon,
		nextIcon,
		Icon,
		contentWidth,
		wrapperWidth,
		klass,
		showArrows,
		hideDisabledArrows,
		centerActive,
		activeClass,
		value,
		multiple,
		mandatory,
		max,
		x,
		next,
		prev,
		touchStartX,
		touchstart,
		touchmove,
		arrowsVisible
	});

	$$self.$inject_state = $$props => {
		if ('contentWidth' in $$props) $$invalidate(7, contentWidth = $$props.contentWidth);
		if ('wrapperWidth' in $$props) $$invalidate(8, wrapperWidth = $$props.wrapperWidth);
		if ('klass' in $$props) $$invalidate(1, klass = $$props.klass);
		if ('showArrows' in $$props) $$invalidate(15, showArrows = $$props.showArrows);
		if ('hideDisabledArrows' in $$props) $$invalidate(2, hideDisabledArrows = $$props.hideDisabledArrows);
		if ('centerActive' in $$props) $$invalidate(16, centerActive = $$props.centerActive);
		if ('activeClass' in $$props) $$invalidate(3, activeClass = $$props.activeClass);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('multiple' in $$props) $$invalidate(4, multiple = $$props.multiple);
		if ('mandatory' in $$props) $$invalidate(5, mandatory = $$props.mandatory);
		if ('max' in $$props) $$invalidate(6, max = $$props.max);
		if ('x' in $$props) $$invalidate(9, x = $$props.x);
		if ('touchStartX' in $$props) touchStartX = $$props.touchStartX;
		if ('arrowsVisible' in $$props) $$invalidate(10, arrowsVisible = $$props.arrowsVisible);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*wrapperWidth, contentWidth, showArrows*/ 33152) {
			$$invalidate(10, arrowsVisible = wrapperWidth < contentWidth && showArrows);
		}
	};

	return [
		value,
		klass,
		hideDisabledArrows,
		activeClass,
		multiple,
		mandatory,
		max,
		contentWidth,
		wrapperWidth,
		x,
		arrowsVisible,
		next,
		prev,
		touchstart,
		touchmove,
		showArrows,
		centerActive,
		slots,
		div0_elementresize_handler,
		div1_elementresize_handler,
		itemgroup_value_binding,
		change_handler,
		$$scope
	];
}

class SlideGroup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				class: 1,
				showArrows: 15,
				hideDisabledArrows: 2,
				centerActive: 16,
				activeClass: 3,
				value: 0,
				multiple: 4,
				mandatory: 5,
				max: 6
			},
			add_css$5
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SlideGroup",
			options,
			id: create_fragment$6.name
		});
	}

	get class() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showArrows() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showArrows(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideDisabledArrows() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideDisabledArrows(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get centerActive() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set centerActive(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeClass() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeClass(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mandatory() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mandatory(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<SlideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<SlideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Window/Window.svelte generated by Svelte v3.42.1 */
const file$5 = "node_modules/svelte-materialify/dist/components/Window/Window.svelte";

function add_css$4(target) {
	append_styles(target, "svelte-197dgbn", ".s-window{position:relative;width:100%;overflow:hidden;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}.s-window.horizontal .s-window-item.active.right,.s-window.horizontal .s-window-item.next:not(.left){transform:translateX(100%)}.s-window.horizontal .s-window-item.active.left,.s-window.horizontal .s-window-item.prev:not(.right){transform:translateX(-100%)}.s-window.vertical .s-window-item.active.right,.s-window.vertical .s-window-item.next:not(.left){transform:translateY(100%)}.s-window.vertical .s-window-item.active.left,.s-window.vertical .s-window-item.prev:not(.right){transform:translateY(-100%)}.s-window.reverse.horizontal .s-window-item.active.right,.s-window.reverse.horizontal .s-window-item.next:not(.left){transform:translateX(-100%)}.s-window.reverse.horizontal .s-window-item.active.left,.s-window.reverse.horizontal .s-window-item.prev:not(.right){transform:translateX(100%)}.s-window.reverse.vertical .s-window-item.active.right,.s-window.reverse.vertical .s-window-item.next:not(.left){transform:translateY(-100%)}.s-window.reverse.vertical .s-window-item.active.left,.s-window.reverse.vertical .s-window-item.prev:not(.right){transform:translateY(100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2luZG93LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUF1RjZDLFNBQUEsQUFBQSxDQUFBLGlwQ0FBODdDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIldpbmRvdy5zdmVsdGUiXX0= */");
}

function create_fragment$5(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "s-window " + /*klass*/ ctx[0]);
			toggle_class(div, "horizontal", !/*vertical*/ ctx[1]);
			toggle_class(div, "vertical", /*vertical*/ ctx[1]);
			toggle_class(div, "reverse", /*reverse*/ ctx[2]);
			add_location(div, file$5, 117, 0, 3562);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[12](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-window " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (dirty & /*klass, vertical*/ 3) {
				toggle_class(div, "horizontal", !/*vertical*/ ctx[1]);
			}

			if (dirty & /*klass, vertical*/ 3) {
				toggle_class(div, "vertical", /*vertical*/ ctx[1]);
			}

			if (dirty & /*klass, reverse*/ 5) {
				toggle_class(div, "reverse", /*reverse*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[12](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const WINDOW = {};

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Window', slots, ['default']);
	let { class: klass = '' } = $$props;
	let { activeClass = 'active' } = $$props;
	let { value = 0 } = $$props;
	let { vertical = false } = $$props;
	let { reverse = false } = $$props;
	let { continuous = true } = $$props;
	let container;
	const windowItems = [];
	let moving = false;

	setContext(WINDOW, window => {
		windowItems.push(window);
	});

	function set(index) {
		const prevIndex = windowItems.findIndex(i => i.classList.contains(activeClass));

		if (!moving && windowItems[index] && index !== prevIndex) {
			moving = true;
			let direction;
			let position;

			if (index > prevIndex) {
				direction = 'left';
				position = 'next';
			} else {
				direction = 'right';
				position = 'prev';
			}

			const prev = windowItems[prevIndex];
			prev.classList.add(direction);
			$$invalidate(3, container.style.height = `${prev.offsetHeight}px`, container);
			const active = windowItems[index];
			active.classList.add(position);
			$$invalidate(3, container.style.height = `${active.offsetHeight}px`, container);
			active.classList.add(direction);

			setTimeout(
				() => {
					prev.classList.remove('active', direction);
					active.classList.add('active');
					active.classList.remove(position, direction);
					$$invalidate(3, container.style.height = null, container);
					moving = false;
					$$invalidate(4, value = index);
				},
				300
			);
		}
	}

	function next() {
		if (value === windowItems.length - 1) {
			if (continuous) set(0);
		} else {
			set(value + 1);
		}
	}

	function previous() {
		if (value === 0) {
			if (continuous) set(windowItems.length - 1);
		} else {
			set(value - 1);
		}
	}

	onMount(() => {
		const activeItem = windowItems[value];
		if (activeItem) activeItem.classList.add(activeClass);
	});

	const writable_props = ['class', 'activeClass', 'value', 'vertical', 'reverse', 'continuous'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Window> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			container = $$value;
			$$invalidate(3, container);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('activeClass' in $$props) $$invalidate(5, activeClass = $$props.activeClass);
		if ('value' in $$props) $$invalidate(4, value = $$props.value);
		if ('vertical' in $$props) $$invalidate(1, vertical = $$props.vertical);
		if ('reverse' in $$props) $$invalidate(2, reverse = $$props.reverse);
		if ('continuous' in $$props) $$invalidate(6, continuous = $$props.continuous);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		WINDOW,
		onMount,
		setContext,
		klass,
		activeClass,
		value,
		vertical,
		reverse,
		continuous,
		container,
		windowItems,
		moving,
		set,
		next,
		previous
	});

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('activeClass' in $$props) $$invalidate(5, activeClass = $$props.activeClass);
		if ('value' in $$props) $$invalidate(4, value = $$props.value);
		if ('vertical' in $$props) $$invalidate(1, vertical = $$props.vertical);
		if ('reverse' in $$props) $$invalidate(2, reverse = $$props.reverse);
		if ('continuous' in $$props) $$invalidate(6, continuous = $$props.continuous);
		if ('container' in $$props) $$invalidate(3, container = $$props.container);
		if ('moving' in $$props) moving = $$props.moving;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 16) {
			set(value);
		}
	};

	return [
		klass,
		vertical,
		reverse,
		container,
		value,
		activeClass,
		continuous,
		set,
		next,
		previous,
		$$scope,
		slots,
		div_binding
	];
}

class Window extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				class: 0,
				activeClass: 5,
				value: 4,
				vertical: 1,
				reverse: 2,
				continuous: 6,
				set: 7,
				next: 8,
				previous: 9
			},
			add_css$4
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Window",
			options,
			id: create_fragment$5.name
		});
	}

	get class() {
		throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeClass() {
		throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeClass(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reverse() {
		throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reverse(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get continuous() {
		throw new Error("<Window>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set continuous(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set() {
		return this.$$.ctx[7];
	}

	set set(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get next() {
		return this.$$.ctx[8];
	}

	set next(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get previous() {
		return this.$$.ctx[9];
	}

	set previous(value) {
		throw new Error("<Window>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Window/WindowItem.svelte generated by Svelte v3.42.1 */
const file$4 = "node_modules/svelte-materialify/dist/components/Window/WindowItem.svelte";

function add_css$3(target) {
	append_styles(target, "svelte-bfn1a8", ".s-window-item{position:relative;display:none;align-items:center;width:100%;float:left;margin-right:-100%;backface-visibility:hidden;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}.s-window-item.active,.s-window-item.next,.s-window-item.prev{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2luZG93SXRlbS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBZ0JpRCxjQUFBLEFBQUEsQ0FBQSxrUEFBK1IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiV2luZG93SXRlbS5zdmVsdGUiXX0= */");
}

function create_fragment$4(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", div_class_value = "s-window-item " + /*klass*/ ctx[0]);
			attr_dev(div, "style", /*style*/ ctx[1]);
			add_location(div, file$4, 29, 0, 699);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[5](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-window-item " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 2) {
				attr_dev(div, "style", /*style*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[5](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('WindowItem', slots, ['default']);
	let window;
	const registerWindow = getContext(WINDOW);
	let { class: klass = '' } = $$props;
	let { style = null } = $$props;

	onMount(() => {
		registerWindow(window);
	});

	const writable_props = ['class', 'style'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WindowItem> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			window = $$value;
			$$invalidate(2, window);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		onMount,
		WINDOW,
		window,
		registerWindow,
		klass,
		style
	});

	$$self.$inject_state = $$props => {
		if ('window' in $$props) $$invalidate(2, window = $$props.window);
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [klass, style, window, $$scope, slots, div_binding];
}

class WindowItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { class: 0, style: 1 }, add_css$3);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WindowItem",
			options,
			id: create_fragment$4.name
		});
	}

	get class() {
		throw new Error("<WindowItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<WindowItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<WindowItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<WindowItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Tabs/Tabs.svelte generated by Svelte v3.42.1 */
const file$3 = "node_modules/svelte-materialify/dist/components/Tabs/Tabs.svelte";

function add_css$2(target) {
	append_styles(target, "svelte-1kd25zu", ".s-tabs-bar{border-radius:inherit;height:48px;display:flex;background-color:var(--theme-cards)}.s-tabs-bar [slot=tabs]{display:flex;flex:1 0 auto;position:relative;white-space:nowrap}.s-tabs-bar .s-slide-group{width:100%}.s-tabs-bar.grow .s-tab{flex:1 0 auto;max-width:none}.s-tabs-bar.centered{justify-content:center}.s-tabs-bar.right{justify-content:flex-end}.s-tabs-bar.icons{height:72px}.s-tabs-bar.icons .s-tab{flex-direction:column}.s-tabs-bar.icons .s-tab>.s-icon{margin-bottom:6px}.s-tabs-bar.fixed-tabs .s-tab{flex:1 1 auto;width:100%}.s-tabs-bar.fixed-tabs .s-tab:last-child{margin-right:auto}.s-tab-slider{bottom:0;margin:0 !important;position:absolute;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1);z-index:1;background-color:currentColor;height:2px}.s-tabs{flex:1 1 auto;width:100%}.s-tabs.vertical{display:flex}.s-tabs.vertical .s-tabs-bar{flex:1 0 auto;height:auto}.s-tabs.vertical .s-tabs-bar .s-slide-group__next,.s-tabs.vertical .s-tabs-bar .s-slide-group__prev{display:none}.s-tabs.vertical .s-tabs-bar [slot=tabs]{flex-direction:column}.s-tabs.vertical .s-tabs-bar .s-tab-slider{left:0;width:2px}.s-tabs.vertical .s-tabs-bar .s-tab{height:48px}.s-tabs.vertical .s-tabs-bar.icons .s-tab{height:72px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFicy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0QyQyxXQUFBLEFBQUEsQ0FBQSx1ckNBQXNqRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUYWJzLnN2ZWx0ZSJdfQ== */");
}

const get_tabs_slot_changes = dirty => ({});
const get_tabs_slot_context = ctx => ({});

// (149:6) {#if slider}
function create_if_block(ctx) {
	let div;
	let div_class_value;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", div_class_value = "s-tab-slider " + /*sliderClass*/ ctx[10]);
			add_location(div, file$3, 149, 8, 3566);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[17](div);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*sliderClass*/ 1024 && div_class_value !== (div_class_value = "s-tab-slider " + /*sliderClass*/ ctx[10])) {
				attr_dev(div, "class", div_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[17](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(149:6) {#if slider}",
		ctx
	});

	return block;
}

// (141:4) <SlideGroup       bind:value       mandatory       {centerActive}       {showArrows}       on:change={moveSlider}       on:change>
function create_default_slot_1$1(ctx) {
	let t;
	let if_block_anchor;
	let current;
	const tabs_slot_template = /*#slots*/ ctx[16].tabs;
	const tabs_slot = create_slot(tabs_slot_template, ctx, /*$$scope*/ ctx[21], get_tabs_slot_context);
	let if_block = /*slider*/ ctx[9] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (tabs_slot) tabs_slot.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (tabs_slot) {
				tabs_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (tabs_slot) {
				if (tabs_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot_base(
						tabs_slot,
						tabs_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(tabs_slot_template, /*$$scope*/ ctx[21], dirty, get_tabs_slot_changes),
						get_tabs_slot_context
					);
				}
			}

			if (/*slider*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabs_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabs_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (tabs_slot) tabs_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(141:4) <SlideGroup       bind:value       mandatory       {centerActive}       {showArrows}       on:change={moveSlider}       on:change>",
		ctx
	});

	return block;
}

// (154:2) <Window bind:this={windowComponent}>
function create_default_slot$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(154:2) <Window bind:this={windowComponent}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div1;
	let div0;
	let slidegroup;
	let updating_value;
	let div0_class_value;
	let t;
	let window;
	let current;

	function slidegroup_value_binding(value) {
		/*slidegroup_value_binding*/ ctx[18](value);
	}

	let slidegroup_props = {
		mandatory: true,
		centerActive: /*centerActive*/ ctx[2],
		showArrows: /*showArrows*/ ctx[3],
		$$slots: { default: [create_default_slot_1$1] },
		$$scope: { ctx }
	};

	if (/*value*/ ctx[0] !== void 0) {
		slidegroup_props.value = /*value*/ ctx[0];
	}

	slidegroup = new SlideGroup({ props: slidegroup_props, $$inline: true });
	binding_callbacks.push(() => bind(slidegroup, 'value', slidegroup_value_binding));
	slidegroup.$on("change", /*moveSlider*/ ctx[14]);
	slidegroup.$on("change", /*change_handler*/ ctx[19]);

	let window_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};

	window = new Window({ props: window_props, $$inline: true });
	/*window_binding*/ ctx[20](window);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			create_component(slidegroup.$$.fragment);
			t = space();
			create_component(window.$$.fragment);
			attr_dev(div0, "class", div0_class_value = "s-tabs-bar " + /*klass*/ ctx[1]);
			attr_dev(div0, "role", "tablist");
			toggle_class(div0, "fixed-tabs", /*fixedTabs*/ ctx[4]);
			toggle_class(div0, "grow", /*grow*/ ctx[5]);
			toggle_class(div0, "centered", /*centered*/ ctx[6]);
			toggle_class(div0, "right", /*right*/ ctx[7]);
			toggle_class(div0, "icons", /*icons*/ ctx[8]);
			add_location(div0, file$3, 132, 2, 3222);
			attr_dev(div1, "class", "s-tabs");
			attr_dev(div1, "role", "tablist");
			toggle_class(div1, "vertical", /*vertical*/ ctx[11]);
			add_location(div1, file$3, 131, 0, 3169);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			mount_component(slidegroup, div0, null);
			append_dev(div1, t);
			mount_component(window, div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const slidegroup_changes = {};
			if (dirty & /*centerActive*/ 4) slidegroup_changes.centerActive = /*centerActive*/ ctx[2];
			if (dirty & /*showArrows*/ 8) slidegroup_changes.showArrows = /*showArrows*/ ctx[3];

			if (dirty & /*$$scope, sliderClass, sliderElement, slider*/ 2102784) {
				slidegroup_changes.$$scope = { dirty, ctx };
			}

			if (!updating_value && dirty & /*value*/ 1) {
				updating_value = true;
				slidegroup_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			slidegroup.$set(slidegroup_changes);

			if (!current || dirty & /*klass*/ 2 && div0_class_value !== (div0_class_value = "s-tabs-bar " + /*klass*/ ctx[1])) {
				attr_dev(div0, "class", div0_class_value);
			}

			if (dirty & /*klass, fixedTabs*/ 18) {
				toggle_class(div0, "fixed-tabs", /*fixedTabs*/ ctx[4]);
			}

			if (dirty & /*klass, grow*/ 34) {
				toggle_class(div0, "grow", /*grow*/ ctx[5]);
			}

			if (dirty & /*klass, centered*/ 66) {
				toggle_class(div0, "centered", /*centered*/ ctx[6]);
			}

			if (dirty & /*klass, right*/ 130) {
				toggle_class(div0, "right", /*right*/ ctx[7]);
			}

			if (dirty & /*klass, icons*/ 258) {
				toggle_class(div0, "icons", /*icons*/ ctx[8]);
			}

			const window_changes = {};

			if (dirty & /*$$scope*/ 2097152) {
				window_changes.$$scope = { dirty, ctx };
			}

			window.$set(window_changes);

			if (dirty & /*vertical*/ 2048) {
				toggle_class(div1, "vertical", /*vertical*/ ctx[11]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(slidegroup.$$.fragment, local);
			transition_in(window.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(slidegroup.$$.fragment, local);
			transition_out(window.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(slidegroup);
			/*window_binding*/ ctx[20](null);
			destroy_component(window);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const TABS = {};

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Tabs', slots, ['tabs','default']);
	let sliderElement;
	let windowComponent;
	const tabs = [];
	let { class: klass = '' } = $$props;
	let { value = 0 } = $$props;
	let { centerActive = false } = $$props;
	let { showArrows = true } = $$props;
	let { fixedTabs = false } = $$props;
	let { grow = false } = $$props;
	let { centered = false } = $$props;
	let { right = false } = $$props;
	let { icons = false } = $$props;
	let { slider = true } = $$props;
	let { sliderClass = '' } = $$props;
	let { ripple = {} } = $$props;
	let { vertical = false } = $$props;

	setContext(TABS, {
		ripple,
		registerTab: tab => {
			tabs.push(tab);
		}
	});

	function moveSlider({ detail }) {
		if (slider) {
			const activeTab = tabs[detail];

			if (vertical) {
				$$invalidate(12, sliderElement.style.top = `${activeTab.offsetTop}px`, sliderElement);
				$$invalidate(12, sliderElement.style.height = `${activeTab.offsetHeight}px`, sliderElement);
			} else {
				$$invalidate(12, sliderElement.style.left = `${activeTab.offsetLeft}px`, sliderElement);
				$$invalidate(12, sliderElement.style.width = `${activeTab.offsetWidth}px`, sliderElement);
			}
		}

		windowComponent.set(value);
	}

	onMount(() => {
		moveSlider({ detail: value });
	});

	const writable_props = [
		'class',
		'value',
		'centerActive',
		'showArrows',
		'fixedTabs',
		'grow',
		'centered',
		'right',
		'icons',
		'slider',
		'sliderClass',
		'ripple',
		'vertical'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			sliderElement = $$value;
			$$invalidate(12, sliderElement);
		});
	}

	function slidegroup_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function window_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			windowComponent = $$value;
			$$invalidate(13, windowComponent);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(1, klass = $$props.class);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('centerActive' in $$props) $$invalidate(2, centerActive = $$props.centerActive);
		if ('showArrows' in $$props) $$invalidate(3, showArrows = $$props.showArrows);
		if ('fixedTabs' in $$props) $$invalidate(4, fixedTabs = $$props.fixedTabs);
		if ('grow' in $$props) $$invalidate(5, grow = $$props.grow);
		if ('centered' in $$props) $$invalidate(6, centered = $$props.centered);
		if ('right' in $$props) $$invalidate(7, right = $$props.right);
		if ('icons' in $$props) $$invalidate(8, icons = $$props.icons);
		if ('slider' in $$props) $$invalidate(9, slider = $$props.slider);
		if ('sliderClass' in $$props) $$invalidate(10, sliderClass = $$props.sliderClass);
		if ('ripple' in $$props) $$invalidate(15, ripple = $$props.ripple);
		if ('vertical' in $$props) $$invalidate(11, vertical = $$props.vertical);
		if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		TABS,
		SlideGroup,
		Window,
		onMount,
		setContext,
		sliderElement,
		windowComponent,
		tabs,
		klass,
		value,
		centerActive,
		showArrows,
		fixedTabs,
		grow,
		centered,
		right,
		icons,
		slider,
		sliderClass,
		ripple,
		vertical,
		moveSlider
	});

	$$self.$inject_state = $$props => {
		if ('sliderElement' in $$props) $$invalidate(12, sliderElement = $$props.sliderElement);
		if ('windowComponent' in $$props) $$invalidate(13, windowComponent = $$props.windowComponent);
		if ('klass' in $$props) $$invalidate(1, klass = $$props.klass);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('centerActive' in $$props) $$invalidate(2, centerActive = $$props.centerActive);
		if ('showArrows' in $$props) $$invalidate(3, showArrows = $$props.showArrows);
		if ('fixedTabs' in $$props) $$invalidate(4, fixedTabs = $$props.fixedTabs);
		if ('grow' in $$props) $$invalidate(5, grow = $$props.grow);
		if ('centered' in $$props) $$invalidate(6, centered = $$props.centered);
		if ('right' in $$props) $$invalidate(7, right = $$props.right);
		if ('icons' in $$props) $$invalidate(8, icons = $$props.icons);
		if ('slider' in $$props) $$invalidate(9, slider = $$props.slider);
		if ('sliderClass' in $$props) $$invalidate(10, sliderClass = $$props.sliderClass);
		if ('ripple' in $$props) $$invalidate(15, ripple = $$props.ripple);
		if ('vertical' in $$props) $$invalidate(11, vertical = $$props.vertical);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		value,
		klass,
		centerActive,
		showArrows,
		fixedTabs,
		grow,
		centered,
		right,
		icons,
		slider,
		sliderClass,
		vertical,
		sliderElement,
		windowComponent,
		moveSlider,
		ripple,
		slots,
		div_binding,
		slidegroup_value_binding,
		change_handler,
		window_binding,
		$$scope
	];
}

class Tabs extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				class: 1,
				value: 0,
				centerActive: 2,
				showArrows: 3,
				fixedTabs: 4,
				grow: 5,
				centered: 6,
				right: 7,
				icons: 8,
				slider: 9,
				sliderClass: 10,
				ripple: 15,
				vertical: 11
			},
			add_css$2
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tabs",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get centerActive() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set centerActive(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showArrows() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showArrows(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fixedTabs() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fixedTabs(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get grow() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set grow(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get centered() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set centered(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icons() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icons(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slider() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slider(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliderClass() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliderClass(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ripple() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ripple(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Tabs/Tab.svelte generated by Svelte v3.42.1 */
const file$2 = "node_modules/svelte-materialify/dist/components/Tabs/Tab.svelte";

function add_css$1(target) {
	append_styles(target, "svelte-2kddgj", ".s-tab{align-items:center;display:flex;flex:0 1 auto;font-size:.875rem;font-weight:500;justify-content:center;letter-spacing:.0892857143em;line-height:normal;min-width:90px;max-width:360px;outline:none;padding:0 16px;position:relative;text-align:center;text-decoration:none;text-transform:uppercase;transition:none;user-select:none;color:inherit}.s-tab:before{background-color:currentColor;bottom:0;content:\"\";left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}.s-tab:hover:before{opacity:.16}.s-tab.focus-visible:before{opacity:.2}.s-tab:not(.disabled){cursor:pointer}.s-tab.disabled{pointer-events:none;opacity:.5}.s-tab:not(.active),.s-tab:not(.active)>.s-btn,.s-tab:not(.active)>.s-icon{color:var(--theme-tabs)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFiLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFvQzBDLE1BQUEsQUFBQSxDQUFBLHN3QkFBMDJCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlRhYi5zdmVsdGUiXX0= */");
}

function create_fragment$2(ctx) {
	let button;
	let button_class_value;
	let button_tabindex_value;
	let Class_action;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	const block = {
		c: function create() {
			button = element("button");
			if (default_slot) default_slot.c();
			attr_dev(button, "class", button_class_value = "s-tab s-slide-item " + /*klass*/ ctx[0]);
			attr_dev(button, "role", "tab");
			attr_dev(button, "aria-selected", /*active*/ ctx[4]);
			attr_dev(button, "tabindex", button_tabindex_value = /*disabled*/ ctx[2] ? -1 : 0);
			toggle_class(button, "disabled", /*disabled*/ ctx[2]);
			toggle_class(button, "active", /*active*/ ctx[4]);
			add_location(button, file$2, 85, 0, 2026);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (default_slot) {
				default_slot.m(button, null);
			}

			/*button_binding*/ ctx[11](button);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(Class_action = Class.call(null, button, [/*active*/ ctx[4] && /*activeClass*/ ctx[1]])),
					listen_dev(button, "click", /*selectTab*/ ctx[6], false, false, false),
					listen_dev(button, "click", /*click_handler*/ ctx[10], false, false, false),
					action_destroyer(Ripple.call(null, button, /*ripple*/ ctx[5]))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*klass*/ 1 && button_class_value !== (button_class_value = "s-tab s-slide-item " + /*klass*/ ctx[0])) {
				attr_dev(button, "class", button_class_value);
			}

			if (!current || dirty & /*active*/ 16) {
				attr_dev(button, "aria-selected", /*active*/ ctx[4]);
			}

			if (!current || dirty & /*disabled*/ 4 && button_tabindex_value !== (button_tabindex_value = /*disabled*/ ctx[2] ? -1 : 0)) {
				attr_dev(button, "tabindex", button_tabindex_value);
			}

			if (Class_action && is_function(Class_action.update) && dirty & /*active, activeClass*/ 18) Class_action.update.call(null, [/*active*/ ctx[4] && /*activeClass*/ ctx[1]]);

			if (dirty & /*klass, disabled*/ 5) {
				toggle_class(button, "disabled", /*disabled*/ ctx[2]);
			}

			if (dirty & /*klass, active*/ 17) {
				toggle_class(button, "active", /*active*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			/*button_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Tab', slots, ['default']);
	let tab;
	const click = getContext(SLIDE_GROUP);
	const ITEM = getContext(ITEM_GROUP);
	const { ripple, registerTab } = getContext(TABS);
	let { class: klass = '' } = $$props;
	let { value = ITEM.index() } = $$props;
	let { activeClass = ITEM.activeClass } = $$props;
	let { disabled = false } = $$props;
	let active;

	ITEM.register(values => {
		$$invalidate(4, active = values.includes(value));
	});

	function selectTab({ target }) {
		if (!disabled) {
			click(target);
			ITEM.select(value);
		}
	}

	onMount(() => {
		registerTab(tab);
	});

	const writable_props = ['class', 'value', 'activeClass', 'disabled'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tab> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			tab = $$value;
			$$invalidate(3, tab);
		});
	}

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('activeClass' in $$props) $$invalidate(1, activeClass = $$props.activeClass);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		getContext,
		onMount,
		SLIDE_GROUP,
		ITEM_GROUP,
		TABS,
		Class,
		Ripple,
		tab,
		click,
		ITEM,
		ripple,
		registerTab,
		klass,
		value,
		activeClass,
		disabled,
		active,
		selectTab
	});

	$$self.$inject_state = $$props => {
		if ('tab' in $$props) $$invalidate(3, tab = $$props.tab);
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('value' in $$props) $$invalidate(7, value = $$props.value);
		if ('activeClass' in $$props) $$invalidate(1, activeClass = $$props.activeClass);
		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
		if ('active' in $$props) $$invalidate(4, active = $$props.active);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		klass,
		activeClass,
		disabled,
		tab,
		active,
		ripple,
		selectTab,
		value,
		$$scope,
		slots,
		click_handler,
		button_binding
	];
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				class: 0,
				value: 7,
				activeClass: 1,
				disabled: 2
			},
			add_css$1
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tab",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeClass() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeClass(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-materialify/dist/components/Tabs/TabContent.svelte generated by Svelte v3.42.1 */
const file$1 = "node_modules/svelte-materialify/dist/components/Tabs/TabContent.svelte";

// (10:2) <WindowItem>
function create_default_slot$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(10:2) <WindowItem>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let windowitem;
	let div_class_value;
	let current;

	windowitem = new WindowItem({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(windowitem.$$.fragment);
			attr_dev(div, "class", div_class_value = "s-tab-content " + /*klass*/ ctx[0]);
			attr_dev(div, "role", "tabpanel");
			attr_dev(div, "style", /*style*/ ctx[1]);
			add_location(div, file$1, 8, 0, 157);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(windowitem, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const windowitem_changes = {};

			if (dirty & /*$$scope*/ 8) {
				windowitem_changes.$$scope = { dirty, ctx };
			}

			windowitem.$set(windowitem_changes);

			if (!current || dirty & /*klass*/ 1 && div_class_value !== (div_class_value = "s-tab-content " + /*klass*/ ctx[0])) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 2) {
				attr_dev(div, "style", /*style*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(windowitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(windowitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(windowitem);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TabContent', slots, ['default']);
	let { class: klass = '' } = $$props;
	let { style = '' } = $$props;
	const writable_props = ['class', 'style'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabContent> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('class' in $$props) $$invalidate(0, klass = $$props.class);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ WindowItem, klass, style });

	$$self.$inject_state = $$props => {
		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [klass, style, slots, $$scope];
}

class TabContent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { class: 0, style: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TabContent",
			options,
			id: create_fragment$1.name
		});
	}

	get class() {
		throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/pages/tv/[cc].svelte generated by Svelte v3.42.1 */
const file = "src/pages/tv/[cc].svelte";

function add_css(target) {
	append_styles(target, "svelte-3lrdnf", "img.backdrop-img.svelte-3lrdnf{padding-top:3em;filter:blur(4px);background-repeat:no-repeat;width:80%;position:absolute;left:10%;max-height:84%}div.container.svelte-3lrdnf{padding-top:3em;display:block;width:50%;margin:auto}.poster-stack.svelte-3lrdnf{display:flex;flex-wrap:wrap;position:relative}.card.svelte-3lrdnf{padding-top:1vw;display:flex;position:relative;z-index:3}.card-info.svelte-3lrdnf{margin-left:1vw;padding-left:1.5vw;display:block;justify-content:space-between;z-index:1}.provider-logo.svelte-3lrdnf{border-radius:15% 8% 15% 8%;width:4em;z-index:1;box-shadow:0 0 3px black}.providers.svelte-3lrdnf{display:flex;flex-direction:row;gap:0.35vw;min-width:40px;position:relative;z-index:3;padding-top:1em}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2NjXS5zdmVsdGUiLCJtYXBwaW5ncyI6IjhzQkF5S0EiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiW2NjXS5zdmVsdGUiXX0= */");
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (109:4) {:catch error}
function create_catch_block(ctx) {
	let p;
	let t0;
	let t1_value = /*error*/ ctx[15] + "";
	let t1;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Tv details error: ");
			t1 = text(t1_value);
			add_location(p, file, 109, 8, 4727);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_catch_block.name,
		type: "catch",
		source: "(109:4) {:catch error}",
		ctx
	});

	return block;
}

// (33:4) {:then tv}
function create_then_block(ctx) {
	let img0;
	let img0_src_value;
	let t0;
	let div7;
	let div4;
	let div2;
	let img1;
	let img1_src_value;
	let t1;
	let div1;
	let div0;
	let card;
	let t2;
	let div3;
	let t3;
	let div5;
	let t4;
	let h40;
	let t6;
	let tabs;
	let t7;
	let div6;
	let t8;
	let h41;
	let t10;
	let carousel;
	let current;

	card = new Card({
			props: {
				outlined: true,
				shaped: true,
				style: "background: black; opacity: 75%;",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let each_value_2 = /*tv*/ ctx[6].providers;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	tabs = new Tabs({
			props: {
				centerActive: true,
				$$slots: {
					tabs: [create_tabs_slot],
					default: [create_default_slot_2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	carousel = new Carousel_1({
			props: {
				recommendations: /*tv*/ ctx[6].recommendations
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			img0 = element("img");
			t0 = space();
			div7 = element("div");
			div4 = element("div");
			div2 = element("div");
			img1 = element("img");
			t1 = space();
			div1 = element("div");
			div0 = element("div");
			create_component(card.$$.fragment);
			t2 = space();
			div3 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			div5 = element("div");
			t4 = text("\n                ");
			h40 = element("h4");
			h40.textContent = "Seasons";
			t6 = text("\n                \n                ");
			create_component(tabs.$$.fragment);
			t7 = space();
			div6 = element("div");
			t8 = text("\n                ");
			h41 = element("h4");
			h41.textContent = "Recommendations";
			t10 = text("\n                \n                ");
			create_component(carousel.$$.fragment);
			attr_dev(img0, "class", "backdrop-img svelte-3lrdnf");
			if (!src_url_equal(img0.src, img0_src_value = "" + (API_URL + /*tv*/ ctx[6].backdrop_path))) attr_dev(img0, "src", img0_src_value);
			add_location(img0, file, 33, 8, 1070);
			if (!src_url_equal(img1.src, img1_src_value = "" + (API_URL + /*tv*/ ctx[6].poster_path))) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "background");
			set_style(img1, "max-width", "50%");
			set_style(img1, "position", "relative");
			set_style(img1, "border-radius", "5% 2% 5% 2%");
			set_style(img1, "z-index", "1");
			set_style(img1, "box-shadow", "0 0 3px black");
			add_location(img1, file, 37, 20, 1258);
			attr_dev(div0, "class", "d-flex justify-center mt-4 mb-4");
			add_location(div0, file, 41, 24, 1546);
			attr_dev(div1, "class", "card-info svelte-3lrdnf");
			add_location(div1, file, 40, 20, 1498);
			attr_dev(div2, "class", "card svelte-3lrdnf");
			add_location(div2, file, 36, 16, 1219);
			attr_dev(div3, "class", "providers svelte-3lrdnf");
			add_location(div3, file, 57, 16, 2257);
			attr_dev(div4, "class", "poster-stack svelte-3lrdnf");
			add_location(div4, file, 35, 12, 1176);
			add_location(h40, file, 67, 16, 2645);
			set_style(div5, "padding-top", "2vh");
			add_location(div5, file, 65, 12, 2575);
			add_location(h41, file, 103, 16, 4552);
			set_style(div6, "padding-top", "3vh");
			set_style(div6, "padding-bottom", "8vh");
			add_location(div6, file, 101, 12, 4456);
			attr_dev(div7, "class", "container svelte-3lrdnf");
			add_location(div7, file, 34, 8, 1140);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, div4);
			append_dev(div4, div2);
			append_dev(div2, img1);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, div0);
			mount_component(card, div0, null);
			append_dev(div4, t2);
			append_dev(div4, div3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div3, null);
			}

			append_dev(div7, t3);
			append_dev(div7, div5);
			append_dev(div5, t4);
			append_dev(div5, h40);
			append_dev(div5, t6);
			mount_component(tabs, div5, null);
			append_dev(div7, t7);
			append_dev(div7, div6);
			append_dev(div6, t8);
			append_dev(div6, h41);
			append_dev(div6, t10);
			mount_component(carousel, div6, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				card_changes.$$scope = { dirty, ctx };
			}

			card.$set(card_changes);

			if (dirty & /*API_URL, fetchTvDetails*/ 1) {
				each_value_2 = /*tv*/ ctx[6].providers;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			const tabs_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tabs_changes.$$scope = { dirty, ctx };
			}

			tabs.$set(tabs_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			transition_in(tabs.$$.fragment, local);
			transition_in(carousel.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			transition_out(tabs.$$.fragment, local);
			transition_out(carousel.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div7);
			destroy_component(card);
			destroy_each(each_blocks, detaching);
			destroy_component(tabs);
			destroy_component(carousel);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_then_block.name,
		type: "then",
		source: "(33:4) {:then tv}",
		ctx
	});

	return block;
}

// (44:32) <CardTitle style="color: white">
function create_default_slot_6(ctx) {
	let h5;
	let t_value = /*tv*/ ctx[6].name + "";
	let t;

	const block = {
		c: function create() {
			h5 = element("h5");
			t = text(t_value);
			add_location(h5, file, 44, 36, 1785);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h5, anchor);
			append_dev(h5, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(44:32) <CardTitle style=\\\"color: white\\\">",
		ctx
	});

	return block;
}

// (47:32) <CardText style="color: white;">
function create_default_slot_5(ctx) {
	let h6;
	let t0_value = /*tv*/ ctx[6].first_air_date + "";
	let t0;
	let t1;
	let p;
	let t2_value = /*tv*/ ctx[6].overview + "";
	let t2;

	const block = {
		c: function create() {
			h6 = element("h6");
			t0 = text(t0_value);
			t1 = text("\n                                    \n                                    ");
			p = element("p");
			t2 = text(t2_value);
			add_location(h6, file, 47, 36, 1950);
			add_location(p, file, 49, 36, 2057);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h6, anchor);
			append_dev(h6, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t2);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(h6);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(47:32) <CardText style=\\\"color: white;\\\">",
		ctx
	});

	return block;
}

// (43:28) <Card outlined shaped style="background: black; opacity: 75%;">
function create_default_slot_4(ctx) {
	let cardtitle;
	let t;
	let cardtext;
	let current;

	cardtitle = new CardTitle({
			props: {
				style: "color: white",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	cardtext = new CardText({
			props: {
				style: "color: white;",
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cardtitle.$$.fragment);
			t = space();
			create_component(cardtext.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cardtitle, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(cardtext, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cardtitle_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				cardtitle_changes.$$scope = { dirty, ctx };
			}

			cardtitle.$set(cardtitle_changes);
			const cardtext_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				cardtext_changes.$$scope = { dirty, ctx };
			}

			cardtext.$set(cardtext_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cardtitle.$$.fragment, local);
			transition_in(cardtext.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cardtitle.$$.fragment, local);
			transition_out(cardtext.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cardtitle, detaching);
			if (detaching) detach_dev(t);
			destroy_component(cardtext, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(43:28) <Card outlined shaped style=\\\"background: black; opacity: 75%;\\\">",
		ctx
	});

	return block;
}

// (59:20) {#each tv.providers as provider}
function create_each_block_2(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			attr_dev(img, "class", "provider-logo svelte-3lrdnf");
			if (!src_url_equal(img.src, img_src_value = "" + (API_URL + /*provider*/ ctx[12].logo_path))) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "cover");
			add_location(img, file, 59, 24, 2358);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(59:20) {#each tv.providers as provider}",
		ctx
	});

	return block;
}

// (78:28) <TabContent>
function create_default_slot_3(ctx) {
	let br;
	let t0;
	let div1;
	let img;
	let img_src_value;
	let t1;
	let div0;
	let h50;

	let t2_value = (/*season*/ ctx[7].air_date
	? /*season*/ ctx[7].air_date.split('-')[0]
	: "No air date") + "";

	let t2;
	let t3;
	let t4_value = /*season*/ ctx[7].episode_count + "";
	let t4;
	let t5;
	let t6;
	let h51;

	let t7_value = (/*season*/ ctx[7].air_date
	? `Premiered on ${/*season*/ ctx[7].air_date}`
	: "Hasn't aired") + "";

	let t7;
	let t8;
	let p;

	let t9_value = (/*season*/ ctx[7].overview
	? /*season*/ ctx[7].overview
	: "No season overview available.") + "";

	let t9;
	let t10;

	const block = {
		c: function create() {
			br = element("br");
			t0 = space();
			div1 = element("div");
			img = element("img");
			t1 = space();
			div0 = element("div");
			h50 = element("h5");
			t2 = text(t2_value);
			t3 = text("\n                                            | ");
			t4 = text(t4_value);
			t5 = text(" episodes");
			t6 = text("\n                                        \n                                        ");
			h51 = element("h5");
			t7 = text(t7_value);
			t8 = text("\n                                        \n                                        ");
			p = element("p");
			t9 = text(t9_value);
			t10 = space();
			add_location(br, file, 78, 32, 3100);
			if (!src_url_equal(img.src, img_src_value = "" + (API_URL + /*season*/ ctx[7].poster_path))) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "season-content");
			set_style(img, "max-height", "45vh");
			set_style(img, "border-radius", "5% 2% 5% 2%");
			set_style(img, "box-shadow", "0 0 3px black");
			add_location(img, file, 80, 36, 3239);
			add_location(h50, file, 84, 40, 3609);
			add_location(h51, file, 88, 40, 3889);
			add_location(p, file, 92, 40, 4140);
			set_style(div0, "margin-left", "1vw");
			set_style(div0, "min-width", "5vw");
			set_style(div0, "max-height", "5vh");
			add_location(div0, file, 83, 36, 3504);
			set_style(div1, "display", "flex");
			set_style(div1, "margin-bottom", "1em");
			set_style(div1, "margin-left", "1em");
			add_location(div1, file, 79, 32, 3137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, br, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div1, anchor);
			append_dev(div1, img);
			append_dev(div1, t1);
			append_dev(div1, div0);
			append_dev(div0, h50);
			append_dev(h50, t2);
			append_dev(h50, t3);
			append_dev(h50, t4);
			append_dev(h50, t5);
			append_dev(div0, t6);
			append_dev(div0, h51);
			append_dev(h51, t7);
			append_dev(div0, t8);
			append_dev(div0, p);
			append_dev(p, t9);
			insert_dev(target, t10, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(br);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);
			if (detaching) detach_dev(t10);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(78:28) <TabContent>",
		ctx
	});

	return block;
}

// (77:24) {#each tv.seasons as season}
function create_each_block_1(ctx) {
	let tabcontent;
	let current;

	tabcontent = new TabContent({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tabcontent.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tabcontent, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tabcontent_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tabcontent_changes.$$scope = { dirty, ctx };
			}

			tabcontent.$set(tabcontent_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tabcontent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tabcontent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tabcontent, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(77:24) {#each tv.seasons as season}",
		ctx
	});

	return block;
}

// (70:16) <Tabs centerActive>
function create_default_slot_2(ctx) {
	let div;
	let current;
	let each_value_1 = /*tv*/ ctx[6].seasons;
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			add_location(div, file, 75, 20, 2968);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchTvDetails, API_URL*/ 1) {
				each_value_1 = /*tv*/ ctx[6].seasons;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(70:16) <Tabs centerActive>",
		ctx
	});

	return block;
}

// (73:28) <Tab>
function create_default_slot_1(ctx) {
	let t_value = /*season*/ ctx[7].name + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(73:28) <Tab>",
		ctx
	});

	return block;
}

// (72:24) {#each tv.seasons as season}
function create_each_block(ctx) {
	let tab;
	let current;

	tab = new Tab({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(tab.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(tab, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const tab_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				tab_changes.$$scope = { dirty, ctx };
			}

			tab.$set(tab_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(tab.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(tab.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(tab, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(72:24) {#each tv.seasons as season}",
		ctx
	});

	return block;
}

// (71:20) 
function create_tabs_slot(ctx) {
	let div;
	let current;
	let each_value = /*tv*/ ctx[6].seasons;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "slot", "tabs");
			set_style(div, "min-width", "75vw");
			add_location(div, file, 70, 20, 2740);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*fetchTvDetails*/ 1) {
				each_value = /*tv*/ ctx[6].seasons;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_tabs_slot.name,
		type: "slot",
		source: "(71:20) ",
		ctx
	});

	return block;
}

// (31:29)          <Icon spin path={mdiRefresh}
function create_pending_block(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: { spin: true, path: mdiRefresh },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_pending_block.name,
		type: "pending",
		source: "(31:29)          <Icon spin path={mdiRefresh}",
		ctx
	});

	return block;
}

// (29:0) <MaterialApp>
function create_default_slot(ctx) {
	let header;
	let t;
	let await_block_anchor;
	let current;
	header = new Header({ $$inline: true });

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: true,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 6,
		error: 15,
		blocks: [,,,]
	};

	handle_promise(/*fetchTvDetails*/ ctx[0](), info);

	const block = {
		c: function create() {
			create_component(header.$$.fragment);
			t = space();
			await_block_anchor = empty();
			info.block.c();
		},
		m: function mount(target, anchor) {
			mount_component(header, target, anchor);
			insert_dev(target, t, anchor);
			insert_dev(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			update_await_block_branch(info, ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(info.block);
			current = true;
		},
		o: function outro(local) {
			transition_out(header.$$.fragment, local);

			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(29:0) <MaterialApp>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let materialapp;
	let current;

	materialapp = new MaterialApp({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(materialapp.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(materialapp, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const materialapp_changes = {};

			if (dirty & /*$$scope*/ 65536) {
				materialapp_changes.$$scope = { dirty, ctx };
			}

			materialapp.$set(materialapp_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(materialapp.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(materialapp.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(materialapp, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const API_URL = "https://image.tmdb.org/t/p/original/";

function instance($$self, $$props, $$invalidate) {
	let $params;
	let $currentCountry;
	let $url;
	validate_store(params, 'params');
	component_subscribe($$self, params, $$value => $$invalidate(2, $params = $$value));
	validate_store(currentCountry, 'currentCountry');
	component_subscribe($$self, currentCountry, $$value => $$invalidate(3, $currentCountry = $$value));
	validate_store(url, 'url');
	component_subscribe($$self, url, $$value => $$invalidate(4, $url = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('U5Bccu5D', slots, []);
	const tv_detail_url = `http://localhost:1337/tv/${$params.cc}/${$params.id}`;

	const fetchTvDetails = async () => {
		const response = await fetch(tv_detail_url);
		return await response.json();
	};

	let firstLoadCompleted = false;
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<U5Bccu5D> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		goto,
		params,
		url,
		MaterialApp,
		Card,
		CardText,
		Tabs,
		Tab,
		TabContent,
		Icon,
		CardTitle,
		mdiRefresh,
		Header,
		Carousel: Carousel_1,
		currentCountry,
		tv_detail_url,
		fetchTvDetails,
		API_URL,
		firstLoadCompleted,
		$params,
		$currentCountry,
		$url
	});

	$$self.$inject_state = $$props => {
		if ('firstLoadCompleted' in $$props) $$invalidate(1, firstLoadCompleted = $$props.firstLoadCompleted);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$currentCountry, firstLoadCompleted, $url, $params*/ 30) {
			// If the variable changes
			if ($currentCountry) {
				if (firstLoadCompleted === true) {
					window.location.href = $url('./:cc', { cc: $currentCountry, id: $params.id });
				}

				$$invalidate(1, firstLoadCompleted = true);
			}
		}
	};

	return [fetchTvDetails, firstLoadCompleted, $params, $currentCountry, $url];
}

class U5Bccu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bccu5D",
			options,
			id: create_fragment.name
		});
	}
}

export { U5Bccu5D as default };
//# sourceMappingURL=[cc]2.js.map
